<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Clockwork - Cracking the Custom Stream Cipher</title>
    <link rel="stylesheet" href="style.css">
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.0.0-beta3/css/all.min.css">
</head>
<body>

    <nav class="navbar">
        <div class="nav-left">
            <a href="index.html" class="logo">Hopper Blog</a>
        </div>
        <div class="nav-right">
            <a href="writeups.html">‚Üê Back to Write-ups</a>
            <span class="theme-toggle"><i class="fas fa-sun"></i></span> 
        </div>
    </nav>

    <main class="container post-container">
        
        <article class="blog-post">
            <header>
                <p class="post-meta-tag">Reverse Engineering / CTF</p>
                <h1>The challenge description :
                    <br>
                    Hmmmm... what could this be? A quiet little machine keeps ticking, its gears moving in a pattern you can't quite figure out. Something's hidden inside, just waiting for the right touch to reveal its message
                </h1>
                <p class="post-author">By hopper @ NOVA | November 5, 2025</p>
                <hr>
            </header>

            <p>In the world of binary reverse engineering and Capture The Flag (CTF) challenges, we often encounter custom encryption schemes designed not for robust security, but for pure obfuscation. These ciphers aim to make a simple concept, like a repeating XOR, look far more complex.</p>
            <p>We recently encountered a prime example: a custom stream cipher that uses a repeating key and a clever position-dependent bit shift. Let's break down how this cipher works, why it's tricky, and how the provided decryption logic successfully cracks it.</p>

            <h2 id="core-concept"> The Core Concept: More Than Just Repeating XOR</h2>
            <p>A standard repeating XOR cipher is simple: $Ciphertext[i] = Flag[i] \oplus Key[i \pmod L]$. Our custom cipher adds a crucial twist. Instead of XORing the flag byte with the raw key byte, it first dynamically modifies the key byte based on its position in the overall flag.</p>

            <h3 id="encryption-logic">The Encryption Logic Explained</h3>
            <p>The encryption process for the 26-byte flag uses a 16-byte Key Stream Source and follows three steps for each byte at index $i$ (from 0 to 25):</p>
            
            <h4>1. Key Selection</h4>
            <div class="code-block-inline">
                <pre><code>Key Byte = Key Stream Source[i % 16]</code></pre>
            </div>

            <h4>2. Dynamic Bit Shift (The Obfuscation Layer)</h4>
            <p>The Key Byte is modified based on its position modulo 3 ($i \pmod 3$), introducing a cycling shift pattern:</p>
            <ul>
                <li>If $i \pmod 3 = 0$: Shift right by 8 bits ($\text{Key Byte} \gg 8$), resulting in 0.</li>
                <li>If $i \pmod 3 = 1$: Shift left by 1 bit ($\text{Key Byte} \ll 1$).</li>
                <li>If $i \pmod 3 = 2$: Shift left by 2 bits ($\text{Key Byte} \ll 2$).</li>
            </ul>

            <h4>3. Final XOR</h4>
            <div class="code-block-inline">
                <pre><code>Encoded Byte[i] = Flag Byte[i] ^ Shifted Key[i]</code></pre>
            </div>

            <h2 id="decryption">The Decryption Challenge: Inverting the Cipher</h2>
            <p>To recover the original flag, we need to solve for $\text{Flag Byte}[i] = \text{Encoded Byte}[i] \oplus \text{Shifted Key}[i]$. The crucial insight comes from analyzing the binary's **two-pass** decryption function.</p>

            <h3 id="inverse-trap">The Critical Insight: The "Inverse" Trap</h3>
            <p>The presence of two decryption passes, $\text{decrypt(buf, key, 1)}$ and $\text{decrypt(result\_of\_pass\_1, key, 0)}$, implies a two-layer encryption process where the final ciphertext is the result of <strong>two sequential XOR operations</strong>.</p>
            
            <table class="data-table">
                <thead>
                    <tr>
                        <th>Decryption Pass</th>
                        <th>r9 Value</th>
                        <th>Inverted Encryption Step</th>
                        <th>Actual Encryption Op</th>
                    </tr>
                </thead>
                <tbody>
                    <tr>
                        <td>Pass 1 (Inner)</td>
                        <td>1 (Right Shift)</td>
                        <td>Inverts $\text{Op}_B$</td>
                        <td>Left Shift $(\mathbf{i \pmod 3})$</td>
                    </tr>
                    <tr>
                        <td>Pass 2 (Outer)</td>
                        <td>0 (Left Shift)</td>
                        <td>Inverts $\text{Op}_A$</td>
                        <td>Right Shift $(\mathbf{8 - (i \pmod 3)})$</td>
                    </tr>
                </tbody>
            </table>

            <p>This reveals the **two-step encryption formula** used by the binary:</p>
            <div class="code-block-inline">
                <pre><code>Intermediate = Flag ^ (Key >> (8 - (i % 3)))
Ciphertext = Intermediate ^ (Key << (i % 3))</code></pre>
            </div>
            
            <p>The decryption successfully inverts this by applying the inverse operations in reverse order.</p>

            <h2 id="final-flag"> The Flag</h2>
            <p>After executing the two-pass decryption logic with the provided 26-byte ciphertext (<code>buf</code>) and 16-byte key stream (<code>key</code>), the final decoded bytes were converted to their ASCII string representation, yielding the flag:</p>
            <div class="final-flag-block">
                <pre><code>Flag : EnXp{5CR3W_TH3_4WN_4UTH0R}</code></pre>
            </div>
            <p>This challenge is a great reminder that complexity in obfuscation often stems from stacking simple, reversible operations.</p>

        </article>
    </main>
</body>
</html>